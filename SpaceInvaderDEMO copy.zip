


import processing.sound.*;//require sound library
SoundFile backgroundMusic, bulletSound, gameOver, playerDamaged;

Player player;
Lives lives;
Enemy enemy;
Bullet enemyBulletSpeed;
ArrayList<Bullet> bullets;
ArrayList<Enemy> enemies;
ArrayList<EnemyBullet> enemyBullets = new ArrayList<EnemyBullet>();
boolean isGameOver = false;
PImage backgroundImage;
Score score;
GameTimer gameTimer;
boolean gameOverBoolean = false;
boolean difficultySelected = false;
int initialLives;

void setup() {
  score = new Score();
  size(800, 600);
  backgroundImage = loadImage("background.jpg");
  backgroundImage.resize(width, height);
  lives = new Lives(3);
  player = new Player(this, width/2, height - 60, 3);// 2 can be changed according to difficulty
  bullets = new ArrayList<Bullet>();
  enemies = new ArrayList<Enemy>();
  gameTimer = new GameTimer(67);
  gameTimer.start();
  backgroundMusic = new SoundFile(this, "music.mp3");
  bulletSound = new SoundFile(this, "bullet.wav");
  gameOver = new SoundFile(this, "gameOver1.wav");
  playerDamaged = new SoundFile(this, "playerDamaged.wav");
  backgroundMusic.loop();

  for (int i = 0; i < 10; i++) {
    enemies.add(new Enemy(this, i * 40 + 20, 30));
  }
}


boolean checkCollision(Bullet b, Enemy e) {
  return b.x < e.x + 30 && b.x + 10 > e.x && b.y < e.y + 30 && b.y + 10 > e.y;
}

boolean checkPlayerHit(Player player, EnemyBullet bullet) {
  return bullet.x > player.x && bullet.x < player.x + player.width &&
    bullet.y > player.y && bullet.y < player.y + player.height;
}
void displayDifficultyQuestion() {
  background(backgroundImage);
  textAlign(CENTER, CENTER);
  textSize(32);
  fill(255);
  text("Choose Difficulty (e for Easy, m for Medium, h for Hard):", width / 2, height / 4);
}

void displayGameOver() {
  background(0); // Clear the screen
  fill(255, 0, 0); // Red color for the game over text
  textSize(50);
  textAlign(CENTER, CENTER);
  text("Game Over", width / 2, height / 2); // Display in the center of the screen
  fill(255);
  textSize(30);
  text("Score: " + score.getScore(), width / 2, height / 2 + 50);
}
boolean showDifficultyScreen = true;
String selectedDifficulty = "";

void draw() {
  if (!difficultySelected) {
    displayDifficultyQuestion();
  } else if (!isGameOver) {
    if (!gameTimer.isTimeUp()) {

      gameTimer.update();
      background(backgroundImage);

      // Player movement
      if (moveLeft) {
        player.move(-1);
      }
      if (moveRight) {
        player.move(1);
      }

      player.display();

      for (int i = bullets.size() - 1; i >= 0; i--) {
        Bullet b = bullets.get(i);
        b.display();

        for (int j = enemies.size() - 1; j >= 0; j--) {
          Enemy e = enemies.get(j);
          if (checkCollision(b, e)) {
            b.shooting = false;
            e.alive = false;
          }
        }
      }

      if (enemies.isEmpty()) {
        // Repopulate the enemies ArrayList
        for (int i = 0; i < 10; i++) { // Adjust the number of enemies as needed
          enemies.add(new Enemy(this, i * 40 + 20, 30)); // Adjust positioning as needed
        }
      }

      for (int i = enemies.size() - 1; i >= 0; i--) {
        Enemy e = enemies.get(i);
        if (e.alive) {
          e.display();
          e.move();
        } else {
          enemies.remove(i);
          score.increase(1);
        }
      }

      for (int i = bullets.size() - 1; i >= 0; i--) {
        if (!bullets.get(i).shooting) {
          bullets.remove(i);
        }
      }

      if (random(1) < 0.01) { // Adjust probability as needed
        int randomEnemyIndex = int(random(enemies.size()));
        Enemy randomEnemy = enemies.get(randomEnemyIndex);
        enemyBullets.add(randomEnemy.shoot());
      }

      for (int i = enemyBullets.size() - 1; i >= 0; i--) {
        EnemyBullet bullet = enemyBullets.get(i);
        bullet.display();
        if (!bullet.shooting) {
          enemyBullets.remove(i);
        }
      }

      for (EnemyBullet bullet : enemyBullets) {
        if (checkPlayerHit(player, bullet)) {
          player.isHit = true;
          bullet.shooting = false; // Remove the bullet
          lives.loseLife();; // Subtract a life
        }
      }
      startGame(selectedDifficulty);

      lives.display();
      score.display();
      gameTimer.display();

      // Game over condition
      if (lives.count <= 0) {
        isGameOver = true;
      }
    } else {
      handleGameover();
    }
  } else {
    handleGameover();
  }
}

void handleGameover() {
  backgroundMusic.stop();
  if (!gameOverBoolean) {
    gameOver.play();
    gameOverBoolean = true;
  }
  displayGameOver();
  noLoop();
}

boolean moveLeft = false;
boolean moveRight = false;

void keyPressed() {
  if (showDifficultyScreen) {
    handleDifficultySelection();
  } else {
    // Your existing key press logic
    if (key == 'a') {
      moveLeft = true;
    } else if (key == 'd') {
      moveRight = true;
    } else if (key == ' ') {
      if (bullets.size() < 1) {
        bullets.add(new Bullet(player.x + player.width/2, player.y, 10));
        bulletSound.play();
      }
    }
  }
}


void keyReleased() {
  if (key == 'a') {
    moveLeft = false;
  } else if (key == 'd') {
    moveRight = false;
  }
}

void handleDifficultySelection() {
  if (key == 'e' || key == 'E' || key == 'm' || key == 'M' || key == 'h' || key == 'H') {
    selectedDifficulty = Character.toString(key).toLowerCase();
    startGame(selectedDifficulty);
    showDifficultyScreen = false;
  }
}

void startGame(String selectedDifficulty) {
  difficultySelected = true;

  // Adjust parameters based on difficulty for all enemies
  float bulletSpeed = 0;

  switch (selectedDifficulty) {
    case "e":
      bulletSpeed = 5;
      break;
    case "m":
      bulletSpeed = 7;
      break;
    case "h":
      bulletSpeed = 10;
      break;
    default:
      break;
  }

  // Set bullet speed for each enemy
  for (Enemy enemy : enemies) {
    enemy.setBulletSpeed(bulletSpeed);
  }
}


// Bullet Class

class Bullet {
  float x, y;
  boolean shooting;
  float speed; // Speed of the bullet

  Bullet(float x, float y, int speed) {
    this.x = x;
    this.y = y;
    this.speed = speed;
    shooting = true;
  }

  void display() {
    if (shooting) {
      fill(255, 0, 0); // Default color for player bullet
      ellipse(x, y, 10, 10);
      y -= speed; // Move the bullet
      if (y < 0 || y > height) shooting = false; // Deactivate off-screen bullets
    }
  }
}


// Enemy Class

import processing.core.PApplet;
import processing.core.PImage;


class Enemy {
  float x, y;
  boolean alive;
  float speedX = 2; // Horizontal movement speed
  float dropY = 50; // Vertical drop distance
  PApplet parent; // Reference to the main Processing applet
  PImage enemyImage;
  int bulletSpeed;


  Enemy(PApplet parent, float x, float y) {
    this.parent = parent;
    this.x = x;
    this.y = y;
    alive = true;

    enemyImage = parent.loadImage("Enemy.jpg");
  }

  void display() {
    if (alive) {
      parent.image(enemyImage, x, y, 30, 30);
    }
  }

  void move() {
    x += speedX;
    // Check if the enemy hits the edge of the screen
    if (x <= 0 || x >= width - 30) {
      speedX *= -1; // Reverse direction
      y += dropY;   // Drop down
    }
  }
  void setBulletSpeed(float speed) {
    this.bulletSpeed = (int) speed;
  }

  EnemyBullet shoot() {
    return new EnemyBullet(x + 15, y + 30, bulletSpeed); // Bullet starts from the bottom center of the enemy
  }
}


// EnemyBullet class

class EnemyBullet extends Bullet {

  EnemyBullet(float x, float y, int speed) {
    super(x, y, speed);
  }

  @Override
  void display() {
    if (shooting) {
      fill(0, 255, 255); // Color for enemy bullet
      ellipse(x, y, 10, 10);
      y += speed; // Enemy bullet moves down
      if (y > height) shooting = false; // Deactivate off-screen bullets
    }
  }
}

// GameTimer class

class GameTimer {
    int duration;
    int startTime;
    boolean isTimeUp;

    GameTimer(int durationInSeconds) {
        this.duration = durationInSeconds * 1000; // Convert seconds to milliseconds
        this.isTimeUp = false;
    }

    void start() {
        startTime = millis(); // Record the start time
    }

    void update() {
        if (!isTimeUp && millis() - startTime > duration) {
            isTimeUp = true;
        }
    }

    void display() {
        if (!isTimeUp) {
            int remainingTime = duration - (millis() - startTime);
            int seconds = remainingTime / 1000;
            fill(255); // White color for text
            textSize(20);
            text("Time: " + seconds, width/2, 20); // Display time at the top-right corner
        }
    }

    boolean isTimeUp() {
        return isTimeUp;
    }
}

// Lives class

class Lives {
    int count;
    int initialLives;

    Lives(int initialLives) {
        count = initialLives;
    }

    void loseLife() {
        if (count > 0) {
            count--;
        }
    }

    void display() {
        fill(255, 0, 0); // Red color for lives
        textSize(30);
        text("Lives: " + count, 60, 20); // Display lives at the top-left corner
    }
    
    
}

// Player class

import processing.core.PApplet;
import processing.core.PImage;

class Player {
  float x, y;
  int width = 60, height = 40;
  int speed;
  boolean isHit = false;
  PApplet parent;
  PImage  spaceship;
  int lives;

  Player(PApplet parent,float x, float y, int speed) {
    this.x = x;
    this.y = y;
    this.speed = speed;
    this.parent = parent;
    lives = initialLives;
    
    spaceship = parent.loadImage("spaceshipimage.jpg");
  }

  void display() {
    parent.image(spaceship,x,y,80,60);
  }

  void move(int dir) {
    x += dir * speed;
    // Boundary checking
    x = constrain(x, 0, 800 - this.width); // 800 can be changed according to board size
  }
  
  

}

// Score class

class Score {
    int value;

    Score() {
        value = 0;
    }

    void increase(int amount) {
        value += amount;
    }

    int getScore() {
        return value;
    }

    void display() {
        fill(255);
        textSize(20);
        text("Score: " + value, width - 100, 20);
    }
}

